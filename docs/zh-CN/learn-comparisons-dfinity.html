<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Polkadot and Dfinity · Kusama Guide</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Dfinity calls itself &quot;the internet computer&quot; and positions itself as a sister project to Ethereum. Dfinity has been in development since 2016, with a release called &quot;Copper&quot; supposed to have come out in 2017 but never seemed to have landed. In 2019, the world has yet to see the majority of Dfinity&#x27;s closed source code for their client since they only publish helper libraries on [their GitHub](https://github.com/dfinity). The closed source nature of development is in stark contrast to the development of Polkadot, which has developed its Rust reference implementation in [the open on GitHub](https://github.com/paritytech/polkadot) from the start in 2017."/><meta name="docsearch:language" content="zh-CN"/><meta property="og:title" content="Polkadot and Dfinity · Kusama Guide"/><meta property="og:type" content="website"/><meta property="og:url" content="https://lsaether.github.io/testindex"/><meta property="og:description" content="Dfinity calls itself &quot;the internet computer&quot; and positions itself as a sister project to Ethereum. Dfinity has been in development since 2016, with a release called &quot;Copper&quot; supposed to have come out in 2017 but never seemed to have landed. In 2019, the world has yet to see the majority of Dfinity&#x27;s closed source code for their client since they only publish helper libraries on [their GitHub](https://github.com/dfinity). The closed source nature of development is in stark contrast to the development of Polkadot, which has developed its Rust reference implementation in [the open on GitHub](https://github.com/paritytech/polkadot) from the start in 2017."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/testimg/kusama-brand-assets/Kusama Brand Assets/Symbol (Canary)/Kusama_Canary_white.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Muli&amp;display=swap"/><link rel="stylesheet" href="/css/klaro.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://wiki.polkadot.network/js/load.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.js"></script><script type="text/javascript" src="/js/custom.js"></script><script type="text/javascript" src="/js/klaro-config.js"></script><script type="text/javascript" src="/js/klaro.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/testjs/scrollSpy.js"></script><link rel="stylesheet" href="/testcss/main.css"/><script src="/testjs/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/testzh-CN"><img class="logo" src="/testimg/kusama-brand-assets/Kusama Brand Assets/Symbol (Canary)/Kusama_Canary_white.png" alt="Kusama Guide"/><h2 class="headerTitleWithLogo">Kusama Guide</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/testdocs/zh-CN/kusama-index" target="_self">Kusama</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/testimg/language.svg" alt="Languages icon"/>中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/testdocs/en/learn-comparisons-dfinity">English</a></li><li><a href="https://crowdin.com/project/polkadot-wiki" target="_blank" rel="noreferrer noopener">参与翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/polkadot-wiki/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">Polkadot and Dfinity</h1></header><article><div><span><p>Dfinity calls itself &quot;the internet computer&quot; and positions itself as a sister project to Ethereum. Dfinity has been in development since 2016, with a release called &quot;Copper&quot; supposed to have come out in 2017 but never seemed to have landed. In 2019, the world has yet to see the majority of Dfinity's closed source code for their client since they only publish helper libraries on <a href="https://github.com/dfinity">their GitHub</a>. The closed source nature of development is in stark contrast to the development of Polkadot, which has developed its Rust reference implementation in <a href="https://github.com/paritytech/polkadot">the open on GitHub</a> from the start in 2017.</p>
<h3><a class="anchor" aria-hidden="true" id="算法治理"></a><a href="#算法治理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>算法治理</h3>
<p>Dfinity 是算法治理的有力支持者，已经发布了<a href="https://medium.com/dfinity/the-dfinity-blockchain-nervous-system-a5dd1783288e#.duzxztt9k">两篇</a>关于该主题的<a href="https://medium.com/dfinity/future-governance-integrating-traditional-ai-technology-into-the-blockchain-nervous-system-825ababf9d9">博客文章</a>。</p>
<p>Dfinitiy proposes a governance framework called the Blockchain Nervous System (BNS). However, they have not come forward with any definite algorithms or further information following the publishing of the two previous blog posts in 2018.</p>
<p>The BNS described in the blog posts is, compared to Polkadot's extensive governance mechanisms, a simplified reduction of the potential of on-chain governance. It only decides on chain forks through a &quot;trust the expert&quot; follow-the-heaviest-neuron approach.</p>
<p>Polkadot allows governance mechanisms to be much more fine-grained through mechanisms of conviction voting, a tri-cameral model of checks and balances, and the ability to follow chain upgrades seamlessly without needing to update client software.</p>
<h3><a class="anchor" aria-hidden="true" id="共识"></a><a href="#共识" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>共识</h3>
<p>Dfinity uses a four-layered consensus consisting of an identity layer, a random beacon layer, a blockchain layer, and a notary layer.</p>
<p>The identity layer handles the Proof-of-Stake registration and anti-Sybil mechanism of the consensus protocol. In Polkadot, we would compare the identity layer to a subset of the function of NPoS, which handles the stake deposits and sybil resistance while also acting as the peer-set selection algorithm. It is expected that stake deposits on Dfinity will be a fixed size, so they do not implement a peer-set selection since it is inherent in their PoS; when an account makes a deposit they become a validator. Polkadot is more flexible and allows variable deposits and the ability to act as a nominator to participate in the staking system without needing to run validator infrastructure yourself.</p>
<p>The random beacon layer is used to construct a random number in Dfinity, which is the basis for the blockchain and notary layer. It employs a verifiable random function (VRF) that is based on BLS threshold signatures and requires a distributed key generation (DKG). The BLS threshold based VRF is able to solve the &quot;last actor&quot; problem in which the final participant in the protocol can abort by predicting the randomness and not publishing it. Although Polkadot also employs a VRF in its block production protocol BABE, it does not suffer from the &quot;last actor&quot; problem as it uses a different type of VRF that generates the randomness locally, but still allows global verification. The random beacon is then taken from the VRF outputs from two blocks prior, which can be proven to be secure.</p>
<p>The blockchain and fork resolution layer used in Dfinity is known as <em>probablistic slot protocol</em> and uses the randomness from the random beacon to give priority to each proposer for a particular block. Within a constant block time, all proposals generated are sent to notaries which sign the block from the heaviest weighted proposal that they see and broadcast it. Forks are then decided based on the weight which was assigned to proposers in that round, with the heaviest proposer's block taking priority. Polkadot's BABE block production uses the random beacon from the previous VRF outputs to assign weights to producers too. The individual producers then create local randomness and if it beats a threshold as determined by their weight, that producer will produce a new block. BABE achieves constant block time by having a fallback to the Aura round robin style block assignment if for a particular slot no producer generated a random number that fell below their threshold. In BABE forks can happen if more than one producer pulls a correct &quot;lottery ticket&quot; random number, and in this case will rely on the chain selection rule which uses the last finalized chain from GRANDPA to build on.</p>
<p>Finally, in the notarization and <em>near-instant finality</em> layer of Dfinity, the blocks which are produced in the previous layer are notarized by the committee of validators. The notarization is a timestamp and a proof that the block has been published to the network, which prevents a malicious validator from creating a private chain and revealing it later. The notarization mechanism aims to solve the selfish mining attack and the nothing at stake problem. The notarized blocks are then agreed on in a further finalization mechanism.</p>
<p>One should not pay too much heed to the term <em>near-instant finality</em> because terms like this and &quot;instant finality&quot; are basically just marketing terms for Byzantine agreement protocols, and conceal the actual capability of the finality gadget. For example, the notarization and finality rounds of Dfinity consensus can be compared to the pre-commit and pre-vote rounds of standard BFT protocols. Although, since Dfinity has a two-step mechanism for producing and finalizing blocks (much like how Polkadot has with BABE and GRANDPA), the time-to-finality of both protocols should be comparable. GRANDPA has nice properties like coming to finality on entire chains of blocks instead of single blocks one at a time, which makes it an improvement to the finality mechanism outlined by Dfinity.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 5/5/2020 by w3fbot</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/test" class="nav-home"><img src="/testimg/kusama-brand-assets/Kusama Brand Assets/Symbol (Canary)/Kusama_Canary_white.png" alt="Kusama Guide" width="66" height="58"/></a><div><a href="https://stackoverflow.com/questions/tagged/polkadot" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://riot.w3f.tech/#/room/#polkadot-watercooler:matrix.org">Polkadot Watercooler (Riot Chat)</a><a href="https://twitter.com/polkadotnetwork" target="_blank" rel="noreferrer noopener">Twitter</a></div><a class="github-button" href="https://github.com/paritytech/polkadot" data-icon="octicon-star" data-count-href="/paritytech/polkadot/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></section><section class="row"><div class="copyright">Copyright © 2020 Web3 Foundation</div><a class="item" href="https://polkadot.network/privacy/">Privacy Policy</a><a class="item" href="#" id="cookie-settings">Cookie Settings</a><script>
              var cookieSettings = document.getElementById('cookie-settings');
              cookieSettings.onclick = function() {
                return klaro.show();
              };
              </script></section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8bfa06b56bb8f33e5698c7f40b00b38f',
                indexName: 'polkadot',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:zh-CN"]}
              });
            </script></body></html>