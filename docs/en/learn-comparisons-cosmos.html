<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Polkadot and Cosmos · Kusama Guide</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Polkadot and Cosmos are both protocols that provide an interface for different state machines to"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Polkadot and Cosmos · Kusama Guide"/><meta property="og:type" content="website"/><meta property="og:url" content="https://lsaether.github.io//test/index.html"/><meta property="og:description" content="Polkadot and Cosmos are both protocols that provide an interface for different state machines to"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/test/./img/kusama-brand-assets/Kusama_Canary_white.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Muli&amp;display=swap"/><link rel="stylesheet" href="./css/klaro.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://wiki.polkadot.network/js/load.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.js"></script><script type="text/javascript" src="./js/custom.js"></script><script type="text/javascript" src="./js/klaro-config.js"></script><script type="text/javascript" src="./js/klaro.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/test/js/scrollSpy.js"></script><link rel="stylesheet" href="/test/css/main.css"/><script src="/test/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/test/en"><img class="logo" src="/test/./img/kusama-brand-assets/Kusama_Canary_white.png" alt="Kusama Guide"/><h2 class="headerTitleWithLogo">Kusama Guide</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/test/docs/en/kusama-index.html" target="_self">Kusama</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/test/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/test/docs/zh-CN/learn-comparisons-cosmos.html">中文</a></li><li><a href="https://crowdin.com/project/polkadot-wiki" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/w3f/polkadot-wiki/edit/master/docs/learn-comparisons-cosmos.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Polkadot and Cosmos</h1></header><article><div><span><p>Polkadot and Cosmos are both protocols that provide an interface for different state machines to
communicate with each other. Both protocols are predicated on the thesis that the future will have
multiple blockchains that need to interoperate with each other rather than individual blockchains
existing in isolation.</p>
<h2><a class="anchor" aria-hidden="true" id="model"></a><a href="#model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Model</h2>
<p>Polkadot uses a sharded model where each shard in the protocol has an abstract state transition
function (STF). Polkadot uses WebAssembly (Wasm) as a &quot;meta-protocol&quot;. A shard's STF can be abstract
as long as the validators on Polkadot can execute it within a Wasm environment.</p>
<p>The shards of Polkadot are called &quot;<a href="learn-parachains">parachains</a>&quot;. Every time a parachain wants to
make a state transition, it submits a block (batch of state transitions) along with a state proof
that Polkadot validators can independently verify. These blocks are finalized for the parachains
when they are finalized by Polkadot's Relay Chain, the main chain of the system. As such, all
parachains share state with the entire system, meaning that a chain re-organization of a single
parachain would require a re-organization of all parachains and the Relay Chain.</p>
<p>Cosmos uses a bridge-hub model that connects Tendermint chains. The system can have multiple hubs
(the primary being the &quot;Cosmos Hub&quot;), but each hub connects a group of exterior chains, called
&quot;zones&quot;. Each zone is responsible for securing the chain with a sufficiently staked and
decentralized validator set. Zones send messages and tokens to each other via the hub using a
protocol called Inter-Blockchain Communication (IBC). As zones do not share state, a re-organization
of one zone would not re-organize other zones, meaning each message is trust-bound by the
recipient's trust in the security of the sender.</p>
<h2><a class="anchor" aria-hidden="true" id="architecture"></a><a href="#architecture" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Architecture</h2>
<h3><a class="anchor" aria-hidden="true" id="polkadot"></a><a href="#polkadot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Polkadot</h3>
<p>Polkadot has a Relay Chain acting as the main chain of the system. All validators in Polkadot are on
the Relay Chain. Parachains have collators, who construct and propose parachain blocks to
validators. Collators don't have any security responsibilities, and thus do not require a robust
incentive system. Collators can submit a single parachain block for every Relay Chain block every 6
seconds. Once a parachain submits a block, validators perform a series of availability and validity
checks before committing it to the final chain. Polkadot also has actors called fishermen to flag
any blocks and demand additional validity checks.</p>
<p>Parachain slots are limited, and thus parachain candidates participate in an auction to reserve a
slot for up to two years. For chains that do not have the funding for a parachain slot or the
necessity to execute with a six-second block time, Polkadot also has
<a href="learn-parathreads">parathreads</a>. Parathreads execute on a pay-as-you-go basis, only paying to
execute a block when they need to.</p>
<p>In order to interact with chains that want to use their own finalization process (e.g. Bitcoin),
Polkadot has <a href="learn-bridges">bridge parachains</a> that offer two-way compatibility.</p>
<h3><a class="anchor" aria-hidden="true" id="cosmos"></a><a href="#cosmos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cosmos</h3>
<p>Cosmos has a main chain called a &quot;Hub&quot; that connects other blockchains called &quot;zones&quot;. Cosmos can
have multiple hubs, but this overview will consider a single hub. Each zone must maintain its own
state, and therefore have its own validator community. When a zone wants to communicate with another
zone, it sends packets over IBC. The Hub maintains a multi-token ledger of token balances
(non-transfer messages are relayed but their state not stored in the Hub).</p>
<p>Zones monitor the state of the Hub with a light client, but the Hub does not track zone states.
Zones must use a deterministic finality algorithm (currently, all use Tendermint) and implement the
IBC interface to be able to send messages to other chains through the Hub.</p>
<p>Cosmos can also interact with external chains by using &quot;peg zones&quot;, which are similar to bridge
parachains.</p>
<h2><a class="anchor" aria-hidden="true" id="consensus"></a><a href="#consensus" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consensus</h2>
<p>Polkadot uses a hybrid <a href="learn-consensus">consensus</a> protocol with two sub-protocols: BABE and
GRANDPA, together called &quot;Fast Forward&quot;. BABE (Blind Assignment for Blockchain Extension) uses a
verifiable random function (VRF) to assign slots to validators and a fallback round-robin pattern to
guarantee that each slot has an author. GRANDPA (GHOST-based Recursive Ancestor Deriving Prefix
Agreement) votes on chains, rather than individual blocks. Together, BABE can author candidate
blocks to extend the finalized chain and GRANDPA can finalize them in batches (up to millions of
blocks at a time).</p>
<p>This isolation of tasks provides several benefits. First, it represents a reduction in transport
complexity for both block production and finalization. BABE has linear complexity, making it easy to
scale to thousands of block producers with low networking overhead. GRANDPA has quadratic
complexity, but reduced by a factor of the latency, or how many blocks it finalizes in one batch.</p>
<p>Second, having the capacity to extend the chain with unfinalized blocks allows fishermen and other
validators to perform extensive availability and validity checks to ensure that no invalid state
transitions make their way into the final chain.</p>
<p>Cosmos (both the Hub and the zones) uses Tendermint consensus, a round-robin protocol that provides
instant finality. Block production and finalization are on the same path of the algorithm, meaning
it produces and finalizes one block at a time. Because it is a PBFT-based algorithm (like GRANDPA),
it has quadratic transport complexity, but can only finalize one block at a time.</p>
<h2><a class="anchor" aria-hidden="true" id="staking-mechanics"></a><a href="#staking-mechanics" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Staking Mechanics</h2>
<p>Polkadot uses <a href="learn-staking">Nominated Proof of Stake (NPoS)</a> to select validators using the
<a href="learn-phragmen">sequential Phragmen algorithm</a>. The validator set size is set by governance (1,000
validators planned) and stakers who do not want to run validator infrastructure can nominate up to
16 validators. Phragmen's algorithm selects the optimal allocation of stake, where optimal is based
on having the most evenly staked set.</p>
<p>All validators in Polkadot have the same weight in the consensus protocols. That is, to reach
greater than 2/3 of support for a chain, more than 2/3 of the <em>validators</em> must commit to it, rather
than 2/3 of the <em>stake.</em> Likewise, validator rewards are tied to their activity, primarily block
production and finality justifications, not their amount of stake. This creates an incentive to
nominate validators with lower stake, as they will earn higher returns on their staked tokens.</p>
<p>The Cosmos Hub uses Bonded Proof of Stake (a variant of Delegated PoS) to elect validators. Stakers
must bond funds and submit a delegate transaction for each validator they would like to delegate to
with the number of tokens to delegate. The Cosmos Hub plans to support up to 300 validators.</p>
<p>Consensus voting and rewards are both stake-based in Cosmos. In the case of consensus voting, more
than 2/3 of the <em>stake</em> must commit, rather than 2/3 of the <em>validators.</em> Likewise, a validator with
10% of the total stake will earn 10% of the rewards.</p>
<p>Finally, in Cosmos, if a staker does not vote in a governance referendum, the validators assume
their voting power. Because of this, many validators in Cosmos have zero commission in order to
acquire more control over the protocol. In Polkadot, governance and staking are completely disjoint;
nominating a validator does not assign any governance voting rights to the validator.</p>
<h2><a class="anchor" aria-hidden="true" id="message-passing"></a><a href="#message-passing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Message Passing</h2>
<p>Polkadot uses <a href="learn-crosschain">Cross-Chain Message Passing (XCMP)</a> for parachains to send
arbitrary messages to each other. Parachains open connections with each other and can send messages
via their established channels. If two parachains have any full nodes in common, they can gossip
messages via the full nodes. Otherwise, Relay Chain validators will handle message delivery.
Messages do not pass through the Relay Chain, only proofs of post and channel operations (open,
close, etc.) go into the Relay Chain. This enhances scalability by keeping data on the edges of the
system.</p>
<p>In the case of a chain re-organization, messages can be rolled back to the point of the
re-organization based on the proofs of post in the Relay Chain. The shared state amongst parachains
means that messages are free from trust bounds; they all operate in the same context.</p>
<p>Polkadot has an additional protocol called <a href="learn-spree">SPREE</a> that provides shared logic for
cross-chain messages. Messages sent with SPREE carry additional guarantees about provenance and
interpretation by the receiving chain.</p>
<p>Cosmos uses a cross chain protocol called Inter-Blockchain Communication (IBC). The current
implementation of Cosmos uses the Hub to pass tokens between zones. However, Cosmos does have a new
specification for passing arbitrary data. Nonetheless, as chains do not share state, receiving
chains must trust the security of a message's origin.</p>
<h2><a class="anchor" aria-hidden="true" id="governance"></a><a href="#governance" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Governance</h2>
<p>Polkadot has a multicameral <a href="learn-governance">governance</a> system with several avenues to pass
proposals. All proposals ultimately pass through a public referendum, where the majority of tokens
can always control the outcome. For low-turnout referenda, Polkadot uses adaptive quorum biasing to
set the passing threshold. Referenda can contain a variety of proposals, including fund allocation
from an on-chain <a href="learn-treasury">Treasury</a>. Decisions get enacted on-chain and are binding and
autonomous.</p>
<p>Polkadot has several on-chain, permissionless bodies. The primary one is the Council, which
comprises a set of accounts that are elected in Phragmen fashion. The Council represents minority
interests and as such, proposals that are unanimously approved of by the Council have a lower
passing threshold in the public referendum. There is also a Technical Committee for making technical
recommendations (e.g. emergency runtime upgrade to fix a bug).</p>
<p>Cosmos uses coin-vote signalling to pass referenda. The actual enactment of governance decisions is
carried out via a protocol fork, much like other blockchains. All token holders can vote, however,
if a delegator abstains from a vote then the validator they delegate to assume their voting power.
Validators in Polkadot do not receive any voting power based on their nominators.</p>
<h2><a class="anchor" aria-hidden="true" id="upgrades"></a><a href="#upgrades" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Upgrades</h2>
<p>Using the Wasm meta-protocol, Polkadot can enact chain upgrades and successful proposals without a
hard fork. Anything that is within the STF, the transaction queue, or off-chain workers can be
upgraded without forking the chain.</p>
<p>As Cosmos is not based on a meta-protocol, it must enact upgrades and proposals via a normal forking
mechanism.</p>
<h2><a class="anchor" aria-hidden="true" id="development-framework"></a><a href="#development-framework" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Development Framework</h2>
<p>Both Cosmos and Polkadot are designed such that each chain has its own STF and both provide support
for smart contracts in both Wasm and the Ethereum Virtual Machine (EVM). Polkadot provides an
ahead-of-time Wasm compiler as well as an interpreter (Wasmi) for execution, while Cosmos only
excutes smart contracts in an interpreter.</p>
<p>Cosmos chains can be developed using the Cosmos SDK, written in Go. The Cosmos SDK contains about 10
modules (e.g. staking, governance, etc.) that can be included in a chain's STF. The SDK builds on
top of Tendermint.</p>
<p>The primary development framework for parachains is <a href="https://substrate.dev/docs/en/">Substrate</a>,
written in Rust. Substrate comes with FRAME, a set of about 35 modules (called &quot;pallets&quot;) to use in
a chain's STF. Beyond simply using the pallets, Substrate adds a further layer of abstraction that
allows developers to compose FRAME's pallets by adding custom modules and configuring the parameters
and initial storage values for the chain.</p>
<blockquote>
<p>Note: Polkadot can support an STF written in any language, so long as it compiles to its
meta-protocol Wasm. Likewise, it could still use the Substrate client (database, RPC, networking,
etc.); it only needs to implement the primitives at the interface.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>Polkadot was designed on the principle that scalability and interoperability require shared
validation logic to create a trust-free environment. As more blockchains are developed, their
security must be cooperative, not competitive. Therefore, Polkadot provides the shared validation
logic and security processes across chains so that they can interact knowing that their
interlocutors execute within the same security context.</p>
<p>The Cosmos network uses a bridge-hub model to connect chains with independent security guarantees,
meaning that inter-chain communication is still bounded by the trust that the receiving chain has in
the sending chain.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 6/5/2020 by Logan Saether</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#model">Model</a></li><li><a href="#architecture">Architecture</a><ul class="toc-headings"><li><a href="#polkadot">Polkadot</a></li><li><a href="#cosmos">Cosmos</a></li></ul></li><li><a href="#consensus">Consensus</a></li><li><a href="#staking-mechanics">Staking Mechanics</a></li><li><a href="#message-passing">Message Passing</a></li><li><a href="#governance">Governance</a></li><li><a href="#upgrades">Upgrades</a></li><li><a href="#development-framework">Development Framework</a></li><li><a href="#conclusion">Conclusion</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/test/" class="nav-home"><img src="/test/./img/kusama-brand-assets/Kusama_Canary_white.png" alt="Kusama Guide" width="66" height="58"/></a><div><a href="https://stackoverflow.com/questions/tagged/polkadot" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://riot.w3f.tech/#/room/#polkadot-watercooler:matrix.org">Polkadot Watercooler (Riot Chat)</a><a href="https://twitter.com/polkadotnetwork" target="_blank" rel="noreferrer noopener">Twitter</a></div><a class="github-button" href="https://github.com/paritytech/polkadot" data-icon="octicon-star" data-count-href="/paritytech/polkadot/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></section><section class="row"><div class="copyright">Copyright © 2020 Web3 Foundation</div><a class="item" href="https://polkadot.network/privacy/">Privacy Policy</a><a class="item" href="#" id="cookie-settings">Cookie Settings</a><script>
              var cookieSettings = document.getElementById('cookie-settings');
              cookieSettings.onclick = function() {
                return klaro.show();
              };
              </script></section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8bfa06b56bb8f33e5698c7f40b00b38f',
                indexName: 'polkadot',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:en"]}
              });
            </script></body></html>